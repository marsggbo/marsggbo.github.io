<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://marsggbo.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://marsggbo.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-17T02:15:31+00:00</updated><id>https://marsggbo.github.io/feed.xml</id><title type="html">HE Xin (贺鑫), a.k.a. MARSGGBO</title><subtitle>&quot;SSS: Study, Sleep, Slim&quot; </subtitle><entry><title type="html">对抗训练综述学习笔记</title><link href="https://marsggbo.github.io/blog/2024/%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="alternate" type="text/html" title="对抗训练综述学习笔记"/><published>2024-08-21T14:08:13+00:00</published><updated>2024-08-21T14:08:13+00:00</updated><id>https://marsggbo.github.io/blog/2024/%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><![CDATA[<blockquote> <p>本文基于这篇综述进行讨论学习：《Bai T, Luo J, Zhao J, et al. Recent advances in adversarial training for adversarial robustness[J]. arXiv preprint arXiv:2102.01356, 2021.》</p> </blockquote> <p>对抗训练主要目的是让模型能够对于对抗样本做出正确的判断。常见的对抗样本的生成方式（或者说是对抗攻击）是 Fast Gradient Sign Method (FGSM)。</p> <h1 id="1-对抗攻击">1. 对抗攻击</h1> <p>Fast Gradient Sign Method (FGSM) 是一种用于生成对抗样本的攻击算法，由 Ian Goodfellow 等人在 2014 年提出。FGSM 是一种非常经典且简单的对抗攻击方法，主要用于评估模型对对抗攻击的鲁棒性。下面是 FGSM 的简单介绍：</p> <h2 id="11-fgsm-的原理">1.1 FGSM 的原理</h2> <p>FGSM 利用模型的梯度信息，通过对输入样本施加微小的扰动来生成对抗样本。其基本思想是通过梯度下降的方式找到能使模型产生错误预测的最小扰动。</p> <h3 id="fgsm-的步骤">FGSM 的步骤</h3> <ol> <li><strong>选择损失函数</strong>: 选择一个损失函数$L$，该函数衡量模型的预测与真实标签之间的差距。常用的损失函数是交叉熵损失。</li> <li><strong>计算梯度</strong>: 对输入样本$\mathbf{x}$计算损失函数相对于输入的梯度$\nabla_{\mathbf{x}} L(\mathbf{x}, y)$，其中$y$是真实标签。</li> <li><strong>生成对抗扰动</strong>: 使用梯度信息生成对抗扰动。扰动的公式为： \(\mathbf{x}*{\text{adv}} = \mathbf{x} + \epsilon \cdot \text{sign}(\nabla*{\mathbf{x}} L(\mathbf{x}, y))\) 其中，$\text{sign}(\cdot)$表示符号函数，$\epsilon$是一个小的正数，表示扰动的幅度。</li> <li><strong>生成对抗样本</strong>: 将扰动添加到原始样本中，得到对抗样本$\mathbf{x}_{\text{adv}}$。</li> </ol> <h3 id="例子">例子</h3> <p>假设你有一个图像分类模型，目标是生成一个对抗样本，使模型错误地将一个猫的图像分类为狗。使用 FGSM，你会：</p> <ol> <li><strong>选择损失函数</strong>: 使用交叉熵损失来衡量模型预测的错误程度。</li> <li><strong>计算梯度</strong>: 对猫的图像计算交叉熵损失相对于输入图像的梯度。</li> <li><strong>生成对抗扰动</strong>: 根据梯度的符号生成扰动。比如，梯度的符号告诉我们在每个像素上如何调整以最大化损失。</li> <li><strong>生成对抗样本</strong>: 将生成的扰动添加到原始猫的图像中，得到对抗样本。</li> </ol> <h3 id="fgsm-的特点">FGSM 的特点</h3> <ol> <li><strong>效率</strong>: FGSM 是一种非常快速和简单的攻击方法，因为它只需要计算一次梯度。</li> <li><strong>效果</strong>: 尽管简单，FGSM 能够有效地生成对抗样本，测试模型的鲁棒性。</li> <li><strong>局限性</strong>: FGSM 可能对一些防御方法不够有效，因为它的扰动是单一的，可能不足以击败更复杂的防御策略。</li> </ol> <p>FGSM 作为对抗攻击的基础方法，为进一步研究和开发更复杂的对抗攻击技术提供了重要的理论基础。</p> <p>Iterative FGSM 和 Projected Gradient Descent (PGD) 是对抗攻击中常用的改进方法，相比于原始的 FGSM，它们通过迭代优化过程来生成更强的对抗样本。以下是这两种方法的详细介绍：</p> <h2 id="12-iterative-fgsm">1.2 <strong>Iterative FGSM</strong></h2> <p><strong>原理</strong>: Iterative FGSM，也称为 Iterative Fast Gradient Sign Method，是 FGSM 的一种改进版本。它通过多次迭代的方式生成对抗样本，以增强对抗攻击的效果。</p> <p><strong>步骤</strong>:</p> <ol> <li><strong>初始化对抗样本</strong>: 从原始样本开始，初始对抗样本为$\mathbf{x}_{\text{adv}}^0 = \mathbf{x}$。</li> <li><strong>迭代扰动</strong>: <ul> <li>对每一步$t$（从$t = 0$到$T-1$）: <ul> <li>计算当前对抗样本的梯度$\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y)$。</li> <li>根据梯度生成扰动$\delta_t = \epsilon \cdot \text{sign}(\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y))$。</li> <li>更新对抗样本$\mathbf{x}<em>{\text{adv}}^{t+1} = \mathbf{x}</em>{\text{adv}}^t + \delta_t$。</li> <li>对于下一步，确保对抗样本仍在有效的扰动范围内（如 [0, 1] 之间），有时需要进行投影操作来保持样本的有效性。</li> </ul> </li> </ul> </li> <li><strong>生成最终对抗样本</strong>: 完成所有迭代后，最终的对抗样本为$\mathbf{x}_{\text{adv}}^T$。</li> </ol> <p><strong>特点</strong>:</p> <ul> <li><strong>迭代过程</strong>: 通过多次迭代，每次对抗样本都稍微更新，从而生成更强的对抗样本。</li> <li><strong>效果提升</strong>: 迭代过程使得对抗样本的攻击效果通常比单次 FGSM 攻击要强。</li> </ul> <h2 id="13-projected-gradient-descent-pgd">1.3 <strong>Projected Gradient Descent (PGD)</strong></h2> <p><strong>原理</strong>: PGD 是一种更强的对抗攻击方法，它在 FGSM 的基础上进行了改进，通过迭代和投影操作生成对抗样本。PGD 是一种广泛使用的迭代攻击方法，尤其在研究对抗鲁棒性时。</p> <p><strong>步骤</strong>:</p> <ol> <li><strong>初始化对抗样本</strong>: 从原始样本开始，初始对抗样本为$\mathbf{x}_{\text{adv}}^0 = \mathbf{x}$。</li> <li><strong>迭代更新</strong>: <ul> <li>对每一步$t$（从$t = 0$到$T-1$）: <ul> <li>计算当前对抗样本的梯度$\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y)$。</li> <li>生成扰动$\delta_t = \alpha \cdot \text{sign}(\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y))$，其中$\alpha$是步长。</li> <li>更新对抗样本$\mathbf{x}<em>{\text{adv}}^{t+1} = \mathbf{x}</em>{\text{adv}}^t + \delta_t$。</li> <li><strong>投影操作</strong>: 对于每个更新步骤，将对抗样本投影回有效的扰动范围内，确保对抗样本仍在合法范围内。这通常是通过在对抗样本上应用投影操作来实现的（例如，投影到$\epsilon$-球内）。</li> </ul> </li> </ul> </li> </ol> <p>具体而言，对于$L_{\infty}$ 范数约束的投影操作，给定原始样本 $\mathbf{x}$ 和扰动幅度 $\epsilon$，对抗样本的投影公式可以表示为：</p> \[\mathbf{x}_{\text{adv}} = \text{clip}(\mathbf{x}_{\text{adv}}^{\text{new}}, \mathbf{x} - \epsilon, \mathbf{x} + \epsilon)\] <p>其中：</p> <ul> <li>$\mathbf{x}_{\text{adv}}^{\text{new}}$ 是更新后的对抗样本。</li> <li>$\text{clip}(\cdot, \text{min}, \text{max})$ 是将输入值限制在 $[\text{min}, \text{max}]$ 区间内的函数。</li> </ul> <p>简化地，投影操作可以写为：</p> \[\mathbf{x}_{\text{adv}}[i, j] = \max(\mathbf{x}[i, j] - \epsilon, \min(\mathbf{x}_{\text{adv}}^{\text{new}}[i, j], \mathbf{x}[i, j] + \epsilon))\] <p>这表示对每个像素 $(i, j)$，将对抗样本的值限制在 $[\mathbf{x}[i, j] - \epsilon, \mathbf{x}[i, j] + \epsilon]$ 区间内。</p> <ol> <li><strong>生成最终对抗样本</strong>: 完成所有迭代后，最终的对抗样本为$\mathbf{x}_{\text{adv}}^T$。</li> </ol> <p><strong>特点</strong>:</p> <ul> <li><strong>迭代优化</strong>: 通过多个迭代步骤来优化对抗样本生成过程，提高对抗攻击的效果。</li> <li><strong>投影操作</strong>: 在每次迭代后进行投影，确保对抗样本在扰动约束范围内（例如，$\epsilon$-球内）。</li> </ul> <h3 id="区别与总结">区别与总结</h3> <ul> <li><strong>Iterative FGSM</strong>: <ul> <li>是 FGSM 的迭代版本，通过多次迭代生成更强的对抗样本。</li> <li>每次迭代更新对抗样本，并在更新过程中施加扰动。</li> <li>主要关注通过迭代改进对抗样本的质量，但没有对扰动范围进行显式的限制。</li> </ul> </li> <li><strong>PGD</strong>: <ul> <li>是一种更强的迭代攻击方法，通过每次迭代的梯度更新和投影操作生成对抗样本。</li> <li>包括投影操作，以确保对抗样本在允许的扰动范围内。</li> <li>常被认为是最强的白盒攻击之一，因为它通过迭代和投影的方式可以生成非常强的对抗样本。</li> </ul> </li> </ul> <p>这两种方法都旨在提高对抗样本的攻击效果，但 PGD 的投影操作使其在生成更具攻击性的对抗样本方面通常更为有效。</p> <h1 id="2-对抗训练">2. 对抗训练</h1> <p>为了让模型能够正确处理对抗样本，有很多不同的对抗训练方法被提出。</p> <ol> <li><strong>Adversarial Regularization</strong>：第一种最直观的方法就是把把对抗样本加入到训练集中去训练模型</li> <li><strong>Curriculum-based Adversarial Training</strong>：第二种是根据对抗样本的难易程度进行分类，让模型先学习简单的对抗样本，然后学习困难的。就像人上课一样，先从简单的入手，然后开启苦难模式</li> <li><strong>ensemble adversarial training</strong>：这个也好理解，就是用多个模型生成的对抗样本来训练</li> <li><strong>Adversarial Training with Adaptive $\epsilon$</strong>:这个其实也好理解，前面生成对抗样本公式中有个因子$\epsilon$，通常这是一个固定值，那么对应的对抗样本的难度相对也是在一个固定的范围内。那么一种很自然的思想就是动态改变这个因子的值，那么样本的难度也会发生变化，这样模型训练过程中能够看到不同难度的样本</li> <li><strong>Adversarial Training with Semi/Unsupervised Learning</strong>：有研究发现对抗训练后，模型在对抗测试集上的 accuracy 要明显比对抗训练集上的低。要解决这个问题需要大规模的数据集，但是标签数据非常难获得，所以半监督、无监督训练成为一种可行的方法。不过，你也许会说，不是可以直接用模型生成大量的对抗样本吗，为什么还要用无监督这类方法呢？你说的没错，不过对抗样本生成是基于已有的数据通过加噪声的方式生成的，如果本身的数据集数量有限，那么模型学习到的数据分布也是不够的，对于正常样本的分辨能力可能也会受到影响。</li> <li><strong>Efficient Adversarial Training</strong>：以下是对提高对抗训练效率方法的算法总结： <ul> <li> <ol> <li><strong>Free Adversarial Training (Free-AT) [Shafahi et al., 2019]</strong> <ul> <li>Free-AT的核心思想是在前向传播时重用在反向传播中计算得到的梯度。在这种方法中，模型参数和图像扰动将同时更新。Free-AT通过这种方式减少了计算量，因为不需要多次计算梯度。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>Fast Adversarial Training (FastAT) [Wong et al., 2020]</strong> <ul> <li>FastAT采用了随机初始化的快速梯度符号方法（FGSM）来进行对抗性训练，并证明了其与基于PGD的对抗性训练方法（PGD-AT）同样有效。FastAT通过随机化初始化扰动来减少过拟合，并提高了训练效率。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>GradAlign [Andriushchenko and Flammarion, 2020]</strong> <ul> <li>GradAlign旨在解决快速训练方法中出现的灾难性过拟合问题。该方法通过在梯度更新中引入额外的对齐步骤来改善模型的泛化能力。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>Dynamic Schedule [Vivek and Babu, 2020b]</strong> <ul> <li>动态调度方法通过调整训练过程中的扰动强度和其他超参数，来平衡模型的鲁棒性和准确性。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>Inner Interval Verification [Kim et al., 2021]</strong> <ul> <li>这种方法通过在内部验证扰动的区间来防止过拟合，从而提高模型的泛化能力。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>Domain Adaptation [Song et al., 2019]</strong> <ul> <li>域适应方法通过将对抗性训练应用于不同域的数据来提高模型的泛化能力。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>Regularization Methods [Vivek and Babu, 2020a; Huang et al., 2020]</strong> <ul> <li>正则化方法通过在损失函数中添加正则化项来控制模型的复杂度，从而减少过拟合。</li> </ul> </li> </ol> </li> <li> <ol> <li><strong>You Only Propagate Once (YOPO) [Zhang et al., 2019a]</strong> <ul> <li>YOPO基于Pontryagin的最大原理，通过分析发现对抗性梯度更新仅与神经网络的第一层相关。因此，YOPO专注于在第一层计算对抗性扰动，而其他层保持不变，显著减少了前向和后向传播的次数。</li> </ul> </li> </ol> </li> </ul> </li> </ol> <p>这些方法都旨在解决传统对抗性训练中的计算效率问题，同时尽可能保持或提高模型的对抗性鲁棒性。通过这些技术，研究者们希望能够在有限的计算资源下训练出更加鲁棒的深度学习模型。</p> <footer style="color:white;;background-color:rgb(24,24,24);padding:10px;border-radius:10px;"> <h3 style="text-align:center;color:tomato;font-size:16px;" id="autoid-2-0-0"> <center> <span>微信公众号：AutoML机器学习</span><br/> <img src="https://pic4.zhimg.com/80/v2-87083e55cd41dbef83cc840c142df48a_720w.jpeg" style="width:200px;height:200px"/> </center> <b>MARSGGBO</b><b style="color:white;"><span style="font-size:25px;">♥</span>原创</b><br/> <span>如有意合作或学术讨论欢迎私戳联系~<br/>邮箱:marsggbo@foxmail.com</span> <b style="color:white;"><br/> </b><p><b style="color:white;"></b> </p></h3> </footer>]]></content><author><name></name></author><category term="techniques"/><category term="技术,对抗训练,adversarial"/><category term="training,robustness"/><summary type="html"><![CDATA[本文基于这篇综述进行讨论学习：《Bai T, Luo J, Zhao J, et al. Recent advances in adversarial training for adversarial robustness[J]. arXiv preprint arXiv:2102.01356, 2021.》]]></summary></entry><entry><title type="html">对抗训练综述学习笔记 - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/marsggbo/" rel="alternate" type="text/html" title="对抗训练综述学习笔记 - marsggbo"/><published>2024-08-21T07:20:00+00:00</published><updated>2024-08-21T07:20:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[本文基于这篇综述进行讨论学习：《Bai T, Luo J, Zhao J, et al. Recent advances in adversarial training for adversarial robustness[J]. arXiv preprint arXiv:2102.01356, 2]]></summary></entry><entry><title type="html">【转知乎回答】一文看懂 LLaMA 中的旋转式位置编码（Rotary Position Embedding） - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/llama-rotary-position-embedding-marsggbo/" rel="alternate" type="text/html" title="【转知乎回答】一文看懂 LLaMA 中的旋转式位置编码（Rotary Position Embedding） - marsggbo"/><published>2024-07-19T12:43:00+00:00</published><updated>2024-07-19T12:43:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/-llama-rotary-position-embedding---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/llama-rotary-position-embedding-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[原文： https://zhuanlan.zhihu.com/p/642884818]]></summary></entry><entry><title type="html">二进制中为什么负数是正数取反再加一 - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/marsggbo/" rel="alternate" type="text/html" title="二进制中为什么负数是正数取反再加一 - marsggbo"/><published>2024-07-03T04:13:00+00:00</published><updated>2024-07-03T04:13:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[二进制中的负数表示有一个重要的概念是补码，它是由对应正数二进制取反后再加 1 得到的。但是经常忘记为什么要这么表示，这里结合 chatgpt 解释做个简单的总结。 补码（Two&#39;s Complement）设计的逻辑来自于简化和统一计算机中有符号数的表示和运算。其设计逻辑可以追溯到计算机科学中的一些基]]></summary></entry><entry><title type="html">leetcode 常见题型代码总结 - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/leetcode-marsggbo/" rel="alternate" type="text/html" title="leetcode 常见题型代码总结 - marsggbo"/><published>2024-07-01T11:36:00+00:00</published><updated>2024-07-01T11:36:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/leetcode----marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/leetcode-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[二分查找 class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; left, right=0, len(nums)-1]]></summary></entry><entry><title type="html">Prompt-Tuning、P-Tuning和Prefix-Tuning区别和代码实现【转】 - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/prompt-tuningp-tuningprefix-tuning-marsggbo/" rel="alternate" type="text/html" title="Prompt-Tuning、P-Tuning和Prefix-Tuning区别和代码实现【转】 - marsggbo"/><published>2024-06-30T13:17:00+00:00</published><updated>2024-06-30T13:17:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/prompt-tuningp-tuningprefix-tuning---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/prompt-tuningp-tuningprefix-tuning-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[原文：https://blog.csdn.net/weixin_43863869/article/details/134760405]]></summary></entry><entry><title type="html">Deepspeed ZeRO系列算法原理+通信开销详解 - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/deepspeed-zero-marsggbo/" rel="alternate" type="text/html" title="Deepspeed ZeRO系列算法原理+通信开销详解 - marsggbo"/><published>2024-06-26T15:39:00+00:00</published><updated>2024-06-26T15:39:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/deepspeed-zero---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/deepspeed-zero-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[原文: https://sumanthrh.com/post/distributed-and-efficient-finetuning/#zero-powered-data-parallelism]]></summary></entry><entry><title type="html">NSCC集群使用笔记 - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/nscc-marsggbo/" rel="alternate" type="text/html" title="NSCC集群使用笔记 - marsggbo"/><published>2024-06-09T13:19:00+00:00</published><updated>2024-06-09T13:19:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/nscc---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/nscc-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[1. 账号申请 如果是 NUS，NTU 或者 ASTAR 的学生，可以直接用自己的学校 ID 登录。登录不上的话可以发邮件联系 nscc 工作人员即可，基本上第二天就会回复解决。 2. VSCode 连接 账号申请下来后进官网设置你的 ssh key 之类的东西就可以登录了。第一次登录成功后，可以参]]></summary></entry><entry><title type="html">Huggingface Transformers实现张量并行的小坑 set/get_output_embeddings - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/huggingface-transformers-setget_output_embeddings-marsggbo/" rel="alternate" type="text/html" title="Huggingface Transformers实现张量并行的小坑 set/get_output_embeddings - marsggbo"/><published>2024-05-06T03:17:00+00:00</published><updated>2024-05-06T03:17:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/huggingface-transformers-setget_output_embeddings---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/huggingface-transformers-setget_output_embeddings-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[transformers 库里实现的很多模型会有这么两个函数 get_output_embeddings和 get_output_embeddings。以 SwitchTransformer 为例 class SwitchTransformersForConditionalGeneration(Sw]]></summary></entry><entry><title type="html">Pytorch 如何使用 storage 实现参数 offload？ - marsggbo</title><link href="https://marsggbo.github.io/blog/2024/pytorch-storage-offload-marsggbo/" rel="alternate" type="text/html" title="Pytorch 如何使用 storage 实现参数 offload？ - marsggbo"/><published>2024-04-21T11:08:00+00:00</published><updated>2024-04-21T11:08:00+00:00</updated><id>https://marsggbo.github.io/blog/2024/pytorch--storage--offload---marsggbo</id><content type="html" xml:base="https://marsggbo.github.io/blog/2024/pytorch-storage-offload-marsggbo/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[在深入探讨 PyTorch 中的 Storage 类以及其在参数 offload 场景中的应用之前，让我们首先了解一下 PyTorch 和它的基础组件。PyTorch 是一个广泛使用的开源机器学习库，它不仅提供了强大的计算图功能和自动梯度计算，还允许开发者直接操作底层数据结构，这其中就包括 Stor]]></summary></entry></feed>