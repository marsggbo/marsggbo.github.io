<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content=""> <meta name="msvalidate.01" content=""> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 对抗训练综述学习笔记 | HE Xin (贺鑫), a.k.a. MARSGGBO </title> <meta name="author" content="Xin He"> <meta name="description" content="" sss: study sleep slim> <meta name="keywords" content="PhD, AI, LLM, Neural Architecture Search, NAS, AutoML, Automated Machine Learning,HKBU, NUS, HUST"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%99%A5&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://marsggbo.github.io/blog/2024/%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83%E7%BB%BC%E8%BF%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"> <script src="/assets/js/theme.js?a5ca4084d3b81624bcfa01156dae2b8e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> HE Xin (贺鑫), a.k.a. MARSGGBO </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/others/">Others </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">Teaching </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">对抗训练综述学习笔记</h1> <p class="post-meta"> August 21, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/%E6%8A%80%E6%9C%AF-%E5%AF%B9%E6%8A%97%E8%AE%AD%E7%BB%83-adversarial"> <i class="fa-solid fa-hashtag fa-sm"></i> 技术,对抗训练,adversarial</a>   <a href="/blog/tag/training-robustness"> <i class="fa-solid fa-hashtag fa-sm"></i> training,robustness</a>     ·   <a href="/blog/category/techniques"> <i class="fa-solid fa-tag fa-sm"></i> techniques</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>本文基于这篇综述进行讨论学习：《Bai T, Luo J, Zhao J, et al. Recent advances in adversarial training for adversarial robustness[J]. arXiv preprint arXiv:2102.01356, 2021.》</p> </blockquote> <p>对抗训练主要目的是让模型能够对于对抗样本做出正确的判断。常见的对抗样本的生成方式（或者说是对抗攻击）是 Fast Gradient Sign Method (FGSM)。</p> <h1 id="1-对抗攻击">1. 对抗攻击</h1> <p>Fast Gradient Sign Method (FGSM) 是一种用于生成对抗样本的攻击算法，由 Ian Goodfellow 等人在 2014 年提出。FGSM 是一种非常经典且简单的对抗攻击方法，主要用于评估模型对对抗攻击的鲁棒性。下面是 FGSM 的简单介绍：</p> <h2 id="11-fgsm-的原理">1.1 FGSM 的原理</h2> <p>FGSM 利用模型的梯度信息，通过对输入样本施加微小的扰动来生成对抗样本。其基本思想是通过梯度下降的方式找到能使模型产生错误预测的最小扰动。</p> <h3 id="fgsm-的步骤">FGSM 的步骤</h3> <ol> <li> <strong>选择损失函数</strong>: 选择一个损失函数$L$，该函数衡量模型的预测与真实标签之间的差距。常用的损失函数是交叉熵损失。</li> <li> <strong>计算梯度</strong>: 对输入样本$\mathbf{x}$计算损失函数相对于输入的梯度$\nabla_{\mathbf{x}} L(\mathbf{x}, y)$，其中$y$是真实标签。</li> <li> <strong>生成对抗扰动</strong>: 使用梯度信息生成对抗扰动。扰动的公式为： \(\mathbf{x}*{\text{adv}} = \mathbf{x} + \epsilon \cdot \text{sign}(\nabla*{\mathbf{x}} L(\mathbf{x}, y))\) 其中，$\text{sign}(\cdot)$表示符号函数，$\epsilon$是一个小的正数，表示扰动的幅度。</li> <li> <strong>生成对抗样本</strong>: 将扰动添加到原始样本中，得到对抗样本$\mathbf{x}_{\text{adv}}$。</li> </ol> <h3 id="例子">例子</h3> <p>假设你有一个图像分类模型，目标是生成一个对抗样本，使模型错误地将一个猫的图像分类为狗。使用 FGSM，你会：</p> <ol> <li> <strong>选择损失函数</strong>: 使用交叉熵损失来衡量模型预测的错误程度。</li> <li> <strong>计算梯度</strong>: 对猫的图像计算交叉熵损失相对于输入图像的梯度。</li> <li> <strong>生成对抗扰动</strong>: 根据梯度的符号生成扰动。比如，梯度的符号告诉我们在每个像素上如何调整以最大化损失。</li> <li> <strong>生成对抗样本</strong>: 将生成的扰动添加到原始猫的图像中，得到对抗样本。</li> </ol> <h3 id="fgsm-的特点">FGSM 的特点</h3> <ol> <li> <strong>效率</strong>: FGSM 是一种非常快速和简单的攻击方法，因为它只需要计算一次梯度。</li> <li> <strong>效果</strong>: 尽管简单，FGSM 能够有效地生成对抗样本，测试模型的鲁棒性。</li> <li> <strong>局限性</strong>: FGSM 可能对一些防御方法不够有效，因为它的扰动是单一的，可能不足以击败更复杂的防御策略。</li> </ol> <p>FGSM 作为对抗攻击的基础方法，为进一步研究和开发更复杂的对抗攻击技术提供了重要的理论基础。</p> <p>Iterative FGSM 和 Projected Gradient Descent (PGD) 是对抗攻击中常用的改进方法，相比于原始的 FGSM，它们通过迭代优化过程来生成更强的对抗样本。以下是这两种方法的详细介绍：</p> <h2 id="12-iterative-fgsm">1.2 <strong>Iterative FGSM</strong> </h2> <p><strong>原理</strong>: Iterative FGSM，也称为 Iterative Fast Gradient Sign Method，是 FGSM 的一种改进版本。它通过多次迭代的方式生成对抗样本，以增强对抗攻击的效果。</p> <p><strong>步骤</strong>:</p> <ol> <li> <strong>初始化对抗样本</strong>: 从原始样本开始，初始对抗样本为$\mathbf{x}_{\text{adv}}^0 = \mathbf{x}$。</li> <li> <strong>迭代扰动</strong>: <ul> <li>对每一步$t$（从$t = 0$到$T-1$）: <ul> <li>计算当前对抗样本的梯度$\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y)$。</li> <li>根据梯度生成扰动$\delta_t = \epsilon \cdot \text{sign}(\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y))$。</li> <li>更新对抗样本$\mathbf{x}<em>{\text{adv}}^{t+1} = \mathbf{x}</em>{\text{adv}}^t + \delta_t$。</li> <li>对于下一步，确保对抗样本仍在有效的扰动范围内（如 [0, 1] 之间），有时需要进行投影操作来保持样本的有效性。</li> </ul> </li> </ul> </li> <li> <strong>生成最终对抗样本</strong>: 完成所有迭代后，最终的对抗样本为$\mathbf{x}_{\text{adv}}^T$。</li> </ol> <p><strong>特点</strong>:</p> <ul> <li> <strong>迭代过程</strong>: 通过多次迭代，每次对抗样本都稍微更新，从而生成更强的对抗样本。</li> <li> <strong>效果提升</strong>: 迭代过程使得对抗样本的攻击效果通常比单次 FGSM 攻击要强。</li> </ul> <h2 id="13-projected-gradient-descent-pgd">1.3 <strong>Projected Gradient Descent (PGD)</strong> </h2> <p><strong>原理</strong>: PGD 是一种更强的对抗攻击方法，它在 FGSM 的基础上进行了改进，通过迭代和投影操作生成对抗样本。PGD 是一种广泛使用的迭代攻击方法，尤其在研究对抗鲁棒性时。</p> <p><strong>步骤</strong>:</p> <ol> <li> <strong>初始化对抗样本</strong>: 从原始样本开始，初始对抗样本为$\mathbf{x}_{\text{adv}}^0 = \mathbf{x}$。</li> <li> <strong>迭代更新</strong>: <ul> <li>对每一步$t$（从$t = 0$到$T-1$）: <ul> <li>计算当前对抗样本的梯度$\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y)$。</li> <li>生成扰动$\delta_t = \alpha \cdot \text{sign}(\nabla_{\mathbf{x}} L(\mathbf{x}_{\text{adv}}^t, y))$，其中$\alpha$是步长。</li> <li>更新对抗样本$\mathbf{x}<em>{\text{adv}}^{t+1} = \mathbf{x}</em>{\text{adv}}^t + \delta_t$。</li> <li> <strong>投影操作</strong>: 对于每个更新步骤，将对抗样本投影回有效的扰动范围内，确保对抗样本仍在合法范围内。这通常是通过在对抗样本上应用投影操作来实现的（例如，投影到$\epsilon$-球内）。</li> </ul> </li> </ul> </li> </ol> <p>具体而言，对于$L_{\infty}$ 范数约束的投影操作，给定原始样本 $\mathbf{x}$ 和扰动幅度 $\epsilon$，对抗样本的投影公式可以表示为：</p> \[\mathbf{x}_{\text{adv}} = \text{clip}(\mathbf{x}_{\text{adv}}^{\text{new}}, \mathbf{x} - \epsilon, \mathbf{x} + \epsilon)\] <p>其中：</p> <ul> <li>$\mathbf{x}_{\text{adv}}^{\text{new}}$ 是更新后的对抗样本。</li> <li>$\text{clip}(\cdot, \text{min}, \text{max})$ 是将输入值限制在 $[\text{min}, \text{max}]$ 区间内的函数。</li> </ul> <p>简化地，投影操作可以写为：</p> \[\mathbf{x}_{\text{adv}}[i, j] = \max(\mathbf{x}[i, j] - \epsilon, \min(\mathbf{x}_{\text{adv}}^{\text{new}}[i, j], \mathbf{x}[i, j] + \epsilon))\] <p>这表示对每个像素 $(i, j)$，将对抗样本的值限制在 $[\mathbf{x}[i, j] - \epsilon, \mathbf{x}[i, j] + \epsilon]$ 区间内。</p> <ol> <li> <strong>生成最终对抗样本</strong>: 完成所有迭代后，最终的对抗样本为$\mathbf{x}_{\text{adv}}^T$。</li> </ol> <p><strong>特点</strong>:</p> <ul> <li> <strong>迭代优化</strong>: 通过多个迭代步骤来优化对抗样本生成过程，提高对抗攻击的效果。</li> <li> <strong>投影操作</strong>: 在每次迭代后进行投影，确保对抗样本在扰动约束范围内（例如，$\epsilon$-球内）。</li> </ul> <h3 id="区别与总结">区别与总结</h3> <ul> <li> <strong>Iterative FGSM</strong>: <ul> <li>是 FGSM 的迭代版本，通过多次迭代生成更强的对抗样本。</li> <li>每次迭代更新对抗样本，并在更新过程中施加扰动。</li> <li>主要关注通过迭代改进对抗样本的质量，但没有对扰动范围进行显式的限制。</li> </ul> </li> <li> <strong>PGD</strong>: <ul> <li>是一种更强的迭代攻击方法，通过每次迭代的梯度更新和投影操作生成对抗样本。</li> <li>包括投影操作，以确保对抗样本在允许的扰动范围内。</li> <li>常被认为是最强的白盒攻击之一，因为它通过迭代和投影的方式可以生成非常强的对抗样本。</li> </ul> </li> </ul> <p>这两种方法都旨在提高对抗样本的攻击效果，但 PGD 的投影操作使其在生成更具攻击性的对抗样本方面通常更为有效。</p> <h1 id="2-对抗训练">2. 对抗训练</h1> <p>为了让模型能够正确处理对抗样本，有很多不同的对抗训练方法被提出。</p> <ol> <li> <strong>Adversarial Regularization</strong>：第一种最直观的方法就是把把对抗样本加入到训练集中去训练模型</li> <li> <strong>Curriculum-based Adversarial Training</strong>：第二种是根据对抗样本的难易程度进行分类，让模型先学习简单的对抗样本，然后学习困难的。就像人上课一样，先从简单的入手，然后开启苦难模式</li> <li> <strong>ensemble adversarial training</strong>：这个也好理解，就是用多个模型生成的对抗样本来训练</li> <li> <strong>Adversarial Training with Adaptive $\epsilon$</strong>:这个其实也好理解，前面生成对抗样本公式中有个因子$\epsilon$，通常这是一个固定值，那么对应的对抗样本的难度相对也是在一个固定的范围内。那么一种很自然的思想就是动态改变这个因子的值，那么样本的难度也会发生变化，这样模型训练过程中能够看到不同难度的样本</li> <li> <strong>Adversarial Training with Semi/Unsupervised Learning</strong>：有研究发现对抗训练后，模型在对抗测试集上的 accuracy 要明显比对抗训练集上的低。要解决这个问题需要大规模的数据集，但是标签数据非常难获得，所以半监督、无监督训练成为一种可行的方法。不过，你也许会说，不是可以直接用模型生成大量的对抗样本吗，为什么还要用无监督这类方法呢？你说的没错，不过对抗样本生成是基于已有的数据通过加噪声的方式生成的，如果本身的数据集数量有限，那么模型学习到的数据分布也是不够的，对于正常样本的分辨能力可能也会受到影响。</li> <li> <strong>Efficient Adversarial Training</strong>：以下是对提高对抗训练效率方法的算法总结： <ul> <li> <ol> <li> <strong>Free Adversarial Training (Free-AT) [Shafahi et al., 2019]</strong> <ul> <li>Free-AT的核心思想是在前向传播时重用在反向传播中计算得到的梯度。在这种方法中，模型参数和图像扰动将同时更新。Free-AT通过这种方式减少了计算量，因为不需要多次计算梯度。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>Fast Adversarial Training (FastAT) [Wong et al., 2020]</strong> <ul> <li>FastAT采用了随机初始化的快速梯度符号方法（FGSM）来进行对抗性训练，并证明了其与基于PGD的对抗性训练方法（PGD-AT）同样有效。FastAT通过随机化初始化扰动来减少过拟合，并提高了训练效率。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>GradAlign [Andriushchenko and Flammarion, 2020]</strong> <ul> <li>GradAlign旨在解决快速训练方法中出现的灾难性过拟合问题。该方法通过在梯度更新中引入额外的对齐步骤来改善模型的泛化能力。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>Dynamic Schedule [Vivek and Babu, 2020b]</strong> <ul> <li>动态调度方法通过调整训练过程中的扰动强度和其他超参数，来平衡模型的鲁棒性和准确性。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>Inner Interval Verification [Kim et al., 2021]</strong> <ul> <li>这种方法通过在内部验证扰动的区间来防止过拟合，从而提高模型的泛化能力。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>Domain Adaptation [Song et al., 2019]</strong> <ul> <li>域适应方法通过将对抗性训练应用于不同域的数据来提高模型的泛化能力。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>Regularization Methods [Vivek and Babu, 2020a; Huang et al., 2020]</strong> <ul> <li>正则化方法通过在损失函数中添加正则化项来控制模型的复杂度，从而减少过拟合。</li> </ul> </li> </ol> </li> <li> <ol> <li> <strong>You Only Propagate Once (YOPO) [Zhang et al., 2019a]</strong> <ul> <li>YOPO基于Pontryagin的最大原理，通过分析发现对抗性梯度更新仅与神经网络的第一层相关。因此，YOPO专注于在第一层计算对抗性扰动，而其他层保持不变，显著减少了前向和后向传播的次数。</li> </ul> </li> </ol> </li> </ul> </li> </ol> <p>这些方法都旨在解决传统对抗性训练中的计算效率问题，同时尽可能保持或提高模型的对抗性鲁棒性。通过这些技术，研究者们希望能够在有限的计算资源下训练出更加鲁棒的深度学习模型。</p> <footer style="color:white;;background-color:rgb(24,24,24);padding:10px;border-radius:10px;"> <h3 style="text-align:center;color:tomato;font-size:16px;" id="autoid-2-0-0"> <center> <span>微信公众号：AutoML机器学习</span><br> <img src="https://pic4.zhimg.com/80/v2-87083e55cd41dbef83cc840c142df48a_720w.jpeg" style="width:200px;height:200px"> </center> <b>MARSGGBO</b><b style="color:white;"><span style="font-size:25px;">♥</span>原创</b><br> <span>如有意合作或学术讨论欢迎私戳联系~<br>邮箱:marsggbo@foxmail.com</span> <b style="color:white;"><br> </b> </h3> <p><b style="color:white;"></b> </p> </footer> </div> </article> </div> </div> </div> </div> <div class="clustrmaps-container" style="width: 70%; margin: 0 auto;"> <script type="text/javascript" id="clustrmaps" src="//cdn.clustrmaps.com/map_v2.js?cl=080808&amp;w=300&amp;t=tt&amp;d=MmPhDESko6sM29T5t949L9IK3zTIqI7QXYMuddg4Dos&amp;co=ffffff&amp;cmo=3acc3a&amp;cmn=ff5353&amp;ct=808080"></script> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Xin He. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: November 16, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script type="text/javascript">$(function(){$('[data-toggle="tooltip"]').tooltip()});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?5d75c11f89cd96294bf5e6dd1ee1bb30"></script> <script defer src="/assets/js/common.js?fcfacfb8c6281f5e68d5a7d348186eb1"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id="></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:""});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>